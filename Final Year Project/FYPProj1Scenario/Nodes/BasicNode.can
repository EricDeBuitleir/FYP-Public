/*@!Encoding:1252*/
/*@!Encoding:1252*/
/*@!Encoding:1252*/
includes
{
  #include "..\DataSources_Templates\ASNV_Template_BaseDatatypes.cin"
  #include "..\DataSources_Templates\ASNV_Template_CAM.cin"
  #include "..\DataSources_Templates\ASNV_Template_DENM.cin"
  #include "..\DataSources_Templates\ASNV_Template_MAP.cin"
  #include "..\DataSources_Templates\ASNV_Template_SPAT.cin"
  #include "..\DataSources_Templates\ASNV_Template_IVIM.cin"
  #include "Position.cin"
 // #include "<math.h>"
//  #include "studio.h"
  
}





variables
{
    double vehicleCamLong = 0;
    double vehicleCamLat = 0;
    long stopVehicle = 0;
    double followSpeed = 0;
    long trafficLightState = 0; // 0 = Green, 1 = Yellow, 2 = Red
    int carStationType;
    int carStationId;
    int ledState = 0;
    msTimer lightTimer;
    int carSteerAngle = 0;
    int junctionLength = 30;
    int junctionWidth = 30;
    int junctionHeight = 100;
    int carPositionLat = 0;
    int carPositionLong = 0;
    int isApproachingJunction = 0;
    int isTurningAllowed = 0;
    int sendProcessSignal;
   // int laneBoundaries[4][2] = {{100, 50}, {300, 50}, {300, 100}, {100, 100}};
    int carPositionX = 0; 
    int carPositionY = 0; 
    int previousCarX = 0;
    int previousCarY = 0;
    int carSteeringAngle =0;
    int carSteeringAng = 0;
    int rsuPositionsX;
    int rsuPositionsY;
  
    int dimensions;
    int junction = 0;
    int laneId;
//    double lane1X = 52.2460217;
//    double lane1Y = -7.1280347;
     double lane1X = -7.128107;
    double lane1Y = 52.246004;
    
    struct Lane {
      int id;
      int startX;
      int startY;
      int endX;
      int endY;  
      } lanes[1];
     // lanes[1] = {
     // {0, -7.128107, 52.246004, -7.128207, 52.246104}
        
     // };

   int numLanes = elCount(lanes);
  struct Lane currentLane;
//  struct Lane lanes[numLanes];



  
  
  
}


// On start, callback functions for the most common application messages CAM and DENM are registered.
// It is possible to do the same with the other application messages if needed.

on start
{
  enum CallbackType { OnRx, PreTx };
  
  C2xRegisterCallback(OnRx,  "OnRxCAM",    "CAM");
  C2xRegisterCallback(PreTx, "OnPreTxCAM", "CAM");
  
  C2xRegisterCallback(OnRx,  "OnRxDENM",    "DENM");
  C2xRegisterCallback(PreTx, "OnPreTxDENM", "DENM");
  //setTimer(lightTimer, 0);
  
//  C2xRegisterCallback(OnRx,  "OnRxSPAT",    "SPAT");
//  C2xRegisterCallback(OnRx,  "OnRxMAP",    "MAP");
  
  
    lanes[0].id = 1;
    lanes[0].startX = -7.128107;
    lanes[0].startY = 52.246004;
    lanes[0].endX = -7.128207;
    lanes[0].endY = 52.246104;
  
//    lanes[0].id = 1;
//    lanes[0].startX = convertGPStoSimCoord(-7.128107); // Convert from GPS to simulation coordinates
//    lanes[0].startY = convertGPStoSimCoord(52.246004);
//    lanes[0].endX = convertGPStoSimCoord(-7.128207);
//    lanes[0].endY = convertGPStoSimCoord(52.246104);
}



// Callback function on receiving CAM messages
void OnRxCAM(long channel, long dir, long radioChannel, long signalStrength, long signalQuality, long packet)
{
  struct CAM camPdu;     
  
  double camLong;        
  double camLat;         
  long camStationType;   
  double distanceToCam;   
  long camSpeed;        
  long camHeading;      
  long camStationId;
  long leadSpeed;
 
  long carSpeed;
  double vehiclePosX;
  double vehiclePosY;

  if (!API_GetCAMParams(packet, camPdu))
  {
    vehiclePosX = camPdu.cam.camParameters.basicContainer.referencePosition.longitude;
    vehiclePosY = camPdu.cam.camParameters.basicContainer.referencePosition.latitude;
    camSpeed = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.speed.speedValue;
    camLong = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    camLat = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
    
     carPositionX = (int)(camLong * 1e7); 
      carPositionY = (int)(camLat * 1e7); 
    
    // detmine the lane ID based on function below
    vehiclePosX = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    vehiclePosY = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
    laneId = setLaneId(vehiclePosX, vehiclePosY);
//    laneId = setLaneId(camLong, camLat);
 
// Enumeration values for stationType: 
// -------------------------------------------------------------
// 0 : unknown
// 1 : pedestrian
// 2 : cyclist
// 3 : moped
// 4 : motorcycle
// 5 : passengerCar
// 6 : bus
// 7 : lightTruck
// 8 : heavyTruck
// 9 : trailer
// 10 : specialVehicles
// 11 : tram
// 15 : roadSideUnit
// -------------------------------------------------------------
carStationType = camPdu.cam.camParameters.basicContainer.stationType;
carStationId = camPdu.header.stationID;

   
// Enumeration values for speedValue: 
// -------------------------------------------------------------
// 16383 : unavailable
// -------------------------------------------------------------
   carSpeed = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.speed.speedValue;
   //carSteerAngle = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.steeringWheelAngle.steeringWheelAngleValue;
   carSteerAngle = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.steeringWheelAngle.isValidFlag = 45;
 

 
    distanceToCam = API_PosCalcDistance(vehicleCamLat, vehicleCamLong, camLat, camLong);
//    distanceToCam = API_PosCalcDistance(carPositionX, carPositionY, lane1X, lane1Y);
    
  
    // Debug print statement to check the conditions
    //write("Debug: distanceToCam = %f, camSpeed = %d, stationType = %d, stationID = %d ", distanceToCam, camSpeed, carStationType, carStationId);
//      write("Debug: vehicleCamLat: %f, vehicleCamLong: %f", vehicleCamLat, vehicleCamLong);
//      write("Debug: camLat: %f, camLong: %f", camLat, camLong);
//      write("Debug: Distance to Cam: %f", distanceToCam);
 //       write("Debug: Steering wheel angle : %f", distanceToCam);
  //   write("Test: Car ID %d has %d steeting wheel angle. ", carStationId, carSteerAngle);
    
    
    // CHECK CONDITIONS FOR RSU BASED ON SPEED AND POSITION
    if (distanceToCam <= 10 && distanceToCam > 0 && carStationType == 5 && carSpeed >! 0) {
        defineLaneBoundaries(carSteerAngle, 1, carPositionX, carPositionY, camPdu, lane1X, lane1Y);
//        defineLaneBoundaries(carPositionX, carPositionY, carSteerAngle);
      
        write("Two Car2X services ping each other");
        // CheckRSUAndLED();
    }

    
//    else
    
//        @sysvar::distanceToCam::distanceToCam = 0;
    
  
   }
}


// Callback function before sending CAM messages from IL
void OnPreTxCAM(LONG packet)
{
    struct CAM camPdu; 
  
    // Save the current vehicle's co-ordinates for future distance calculations.
  
    if (!API_GetCAMParams(packet, camPdu))
     {
        vehicleCamLong = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
        vehicleCamLat = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
        followSpeed = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.speed.speedValue;
        
       //` write(" *** Vehicle long = %f lat = %f \n",  vehicleCamLong,  vehicleCamLat );
     }
    
  
    
}

// Callback function on receiving DENM messages
void OnRxDENM(long channel, long dir, long radioChannel, long signalStrength, long signalQuality, long packet)
{
  struct DENM denmPdu;
  int type;
  int stationId;
  
  //write(" *** DENM Received ");
   if (!API_GetDENMparams(packet, denmPdu))
  {
    stationId = denmPdu.header.stationID;
   // write(" DENM stationId = %d", stationId);
    type = denmPdu.denm.situation.eventType.causeCode;
   // write(" DENM Cause Code = %d", type);
  }
    
}

// Callback function before sending DENM messages from IL
void OnPreTxDENM(LONG packet)
{

}



//on key 'x'
//{
  
//  /*
//    Example of how to transmit a DENM messaage.  Note that other parameters such as Station Id, relevance area etc. would need to be
//    included in a realistic DENM message.
//  */
  
//  long packet;
//  double eventPosLat, eventPosLon, eventPosElev;

//  eventPosLat = 48.8233831512772;
//  eventPosLon = 9.093631893371;
//  eventPosElev = 305;

//  packet = C2xInitPacket("DENM");
//  C2xSetTokenInt(packet, "DENM", "denm.situation.eventType.causeCode", 91); // VehicleBreakDown
//  C2xSetTokenPhys(packet, "DENM", "denm.management.eventPosition.latitude", eventPosLat);
//  C2xSetTokenPhys(packet, "DENM", "denm.management.eventPosition.longitude", eventPosLon);
//  C2xSetTokenPhys(packet, "DENM", "denm.management.eventPosition.altitude.altitudeValue", eventPosElev);

// // C2xApplyPathHistory(packet, eventPosLat, eventPosLon, 305, 800, 20, 1);

//  C2xCompletePacket(packet);
//  C2xOutputPacket(packet);
//}





void trafficLightGreen() {
    @sysvar::trafficLightState::trafficLightState = 0; // 0 = Green, 1 = Yellow, 2 = Red
}
void trafficLightYellow() {
    @sysvar::trafficLightState::trafficLightState = 1; // 0 = Green, 1 = Yellow, 2 = Red
}

void trafficLightRed() {
    @sysvar::trafficLightState::trafficLightState = 2; // 0 = Green, 1 = Yellow, 2 = Red
}

on timer lightTimer {
    switch (trafficLightState) {
        case 0: // Green
            trafficLightYellow(); // Light switches from green to yellow
              setTimer(lightTimer, 5000);
            break;
        case 1: // Yellow
            trafficLightRed();// Light switches from yellow to red
              setTimer(lightTimer, 30000);
            break;
        case 2: // Red
            trafficLightGreen();// Light switches from red to green
              setTimer(lightTimer, 20000);
            break;
            
    }
}

    


void VehiclePosition(long packet, struct CAM camPdu)
 {
  int vehiclePosition =0 ;

  int carPositionLat = 0;
  int carPositionLong = 0;
  int  carStationId;
  double camLong;        
  double camLat;         
  long camStationType;   
  double distanceToCam;   
  long camSpeed;        
  long camHeading;      
  long camStationId;
  long leadSpeed;
  
  long carSpeed;

   
   
if (!API_GetCAMParams(packet, camPdu))
    {
        // Extract relevant information from the CAM message
        carPositionLong = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
        carPositionLat = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
        carStationId = camPdu.header.stationID;
        carSteerAngle = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.steeringWheelAngle.steeringWheelAngleValue;





    }
 }
 
 


void carWillContinueRight(struct CAM camPdu) {
    int carX = 0;
    int carY = 0;
    carX = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    carY = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
    
    if (carX > previousCarX && carY < previousCarY) {
        write("Car is continuing to turn right.");
        
        previousCarX = carX;
        previousCarY = carY;
    } else {
        // Car is not continuing to turn right
        write("Car is not continuing to turn right.");
        // Implement additional actions here if needed
      
    }
}
 
// =====================================================================================================================================

// Kind of WORKING ONE
  

void defineLaneBoundaries(int carSteerAng, int laneId, int carPositionX, int carPositionY, struct CAM camPdu, double rsuPositionX, double rsuPositionY) {
    int laneStartX, laneStartY, laneEndX, laneEndY;
    
    carSteerAng = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.steeringWheelAngle.steeringWheelAngleValue = 45;
    carPositionX = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    carPositionY = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
   // laneId = setLaneId(carPositionX, carPositionY, rsuPositionX, rsuPositionY);
    laneId = setLaneId(carPositionX, carPositionY);
  
    if (laneId != -1) {
      write("Debug: Lane ID = %d", laneId); // Debug print statement to check the lane ID
  }
    // Define lane boundaries based on the laneId
    switch (laneId) {
        case 1: // left lane going up
//        laneStartX = rsuPositionX - 10;
//        laneStartY = rsuPositionY - 10; 
//        laneEndX = rsuPositionX + 100;   
//        laneEndY = rsuPositionY + 50;   
          
          laneStartX = lanes[0].startX;
          laneStartY = lanes[0].startY;
          laneEndX = lanes[0].endX;
          laneEndY = lanes[0].endY;
          
        break;
        // Define boundaries for other lanes as needed
    }
    write("Debug: Car Position X = %d, Car Position Y = %d, Debug: Lanes Start X = %d, Lane Start Y = %d, Lane End X = %d, Lane End Y = %d", carPositionX, carPositionY, laneStartX, laneStartY, laneEndX, laneEndY);
    
    // Check if the car's position violates lane boundaries
    if (carPositionX >= laneStartX && carPositionX <= laneEndX && carPositionY >= laneStartY && carPositionY <= laneEndY) {
        // Car is within the lane boundaries, check if it's lane 1
        if (laneId == 1) {
            // Car is in lane 1, check turning direction
            if (carSteerAng >= 44) {
                // Car is turning right while in lane 1, trigger a warning
                write("Warning: Car is looking to turn right while in lane 1!");
                // Signal that turning right is not allowed
                trafficLightRed();
               
            } else {
                // Car is not turning right, reset signals
                trafficLightGreen(); // Or any other appropriate action
            }
        }
    } else {
        // Car is outside lane boundaries, trigger a warning
        write("Warning: Car is outside lane boundaries!");
        // Signal that the car is outside lane boundaries        
    }
}
  

// =====================================================================================================================================



// Going to have to make a method to define the lanes as well as which lane the car is in.
// Will use RSUs for reference point of where the lane is.
// Calculate the distance to the nearest RSU, using the formula shown here. REFERENCE: https://www.cuemath.com/euclidean-distance-formula/
  
  



// =====================================================================================================================================


// WORKING


int setLaneId(double carX, double carY) {

    // Array for our 1 lane, can add more
    double rsuPositionsX[1] = {-7.128107};
    double rsuPositionsY[1] = {52.246004};
 
    int i;
    double dMin = 0; // Initialize to maximum possible value
    int closestRSU = -1; // Initialize to an invalid value since 0 could be a valid index
    
    
    for (i = 0; i < numLanes; i++) {
      double distance = 0;
      double laneCenterX = 0;
      double laneCenterY = 0;
      
      
      laneCenterX = (lanes[i].startX + lanes[i].endX) / 2.0;
      laneCenterY = (lanes[i].startY + lanes[i].endY) / 2.0;
        // Calculate distance using Euclidean distance formula
//        distance = ((carX - (lanes[i].startX +  lanes[i].endX)) * (carX - (lanes[i].startX +  lanes[i].endX))) + ((carY - lanes[i].startY) * (carY - lanes[i].endY));  // had to hard code 'power' as trying to import math.h was crashing CANoe
      distance = ((carX - laneCenterX) * (carX - laneCenterX) + (carY - laneCenterY) * (carY - laneCenterY));
      if (distance < dMin) {
            dMin = distance;
//            closestRSU = i;
            closestRSU = lanes[i].id;
        }
    }
    
    return closestRSU; // Return the closest RSU index
    write("cloest RSU: ", closestRSU);
}


// =====================================================================================================================================




//// =============================================


// ISSUES RIGHT NOW

// 1) Lane doesn't seem to be getting defined as constantly getting out of bounds. POSSIBLE IT COULD BE COORDS NOT BEING RECIEVED CORRECTLY. CAPL doesn't take in co-ords as values. need to convert
// 2) Steering wheel angle doesn't seem to be getting read. Set value manually but still having issues with first issue above

