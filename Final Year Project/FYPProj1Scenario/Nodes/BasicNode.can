/*@!Encoding:1252*/
/*@!Encoding:1252*/
/*@!Encoding:1252*/
includes
{
  #include "..\DataSources_Templates\ASNV_Template_BaseDatatypes.cin"
  #include "..\DataSources_Templates\ASNV_Template_CAM.cin"
  #include "..\DataSources_Templates\ASNV_Template_DENM.cin"
  #include "..\DataSources_Templates\ASNV_Template_MAP.cin"
  #include "..\DataSources_Templates\ASNV_Template_SPAT.cin"
  #include "..\DataSources_Templates\ASNV_Template_IVIM.cin"
  #include "Position.cin"
}

//variables
//{
//  double vehicleCamLong = 0;
//  double vehicleCamLat = 0;
//  long stopVehicle = 0;
//  double followSpeed = 0;
//  long trafficLightState = 0; // 0 = Green, 1 = Yellow, 2 = Red
//  int carStationType;
//  int carStationId;
//  int ledState = 0;
//  msTimer lightTimer;
//  int carSteerAngle;
//  int junctionLength = 30;
//  int junctionWidth = 30;
//  int junctionHeight = 100;
//  int carPositionLat;
//  int carPositionLong;
//  struct VehiclePosition {
//      double xPosition;
//      double yPosition;
//      int vehicleID;
      
//  } vehiclePosition;
  
////  double dmin;  // Variable to store the calculated minimum safe distance
////  double Vr;    // Following vehicle�s longitudinal speed
////  double P;     // Following vehicle�s response time
////  double amax;  // Following vehicle�s maximum longitudinal acceleration during response time [m/s^2]
////  double Bmin;  // Following vehicle�s minimum longitudinal deceleration after response time [m/s^2]
////  double Vf;    // Longitudinal speed of the leading vehicle [m/s]
////  double Bmax;  // Reasonably foreseeable assumed maximum longitudinal deceleration of the leading vehicle [m/s^2]
////  
////  
////  double eqPT1 = 0;
////  double eqPT2 = 0;
////  double eqPT3 = 0;
  
//  long camTestSpeed;
//struct CAM camTest; 
//}




variables
{
    double vehicleCamLong = 0;
    double vehicleCamLat = 0;
    long stopVehicle = 0;
    double followSpeed = 0;
    long trafficLightState = 0; // 0 = Green, 1 = Yellow, 2 = Red
    int carStationType;
    int carStationId;
    int ledState = 0;
    msTimer lightTimer;
    int carSteerAngle = 0;
    int junctionLength = 30;
    int junctionWidth = 30;
    int junctionHeight = 100;
    int carPositionLat = 0;
    int carPositionLong = 0;
    int isApproachingJunction = 0;
    int isTurningAllowed = 0;
    int sendProcessSignal;
    int laneBoundaries[4][2] = {{100, 50}, {300, 50}, {300, 100}, {100, 100}};
    int carPositionX = 0; 
    int carPositionY = 0; 
    int previousCarX = 0;
    int previousCarY = 0;
    int carSteeringAngle =0;
    int dimensions;
    int junction = 0;
    int laneId;
}

// On start, callback functions for the most common application messages CAM and DENM are registered.
// It is possible to do the same with the other application messages if needed.

on start
{
  enum CallbackType { OnRx, PreTx };
  
  C2xRegisterCallback(OnRx,  "OnRxCAM",    "CAM");
  C2xRegisterCallback(PreTx, "OnPreTxCAM", "CAM");
  
  C2xRegisterCallback(OnRx,  "OnRxDENM",    "DENM");
  C2xRegisterCallback(PreTx, "OnPreTxDENM", "DENM");
  //setTimer(lightTimer, 0);


}

// Callback function on receiving CAM messages
void OnRxCAM(long channel, long dir, long radioChannel, long signalStrength, long signalQuality, long packet)
{
  struct CAM camPdu;     
  
  double camLong;        
  double camLat;         
  long camStationType;   
  double distanceToCam;   
  long camSpeed;        
  long camHeading;      
  long camStationId;
  long leadSpeed;
 
  long carSpeed;


  if (!API_GetCAMParams(packet, camPdu))
  {

    camSpeed = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.speed.speedValue;
    camLong = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    camLat = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
    
     carPositionX = (int)(camLong * 1e7); 
      carPositionY = (int)(camLat * 1e7); 
    
    
// Enumeration values for stationType: 
// -------------------------------------------------------------
// 0 : unknown
// 1 : pedestrian
// 2 : cyclist
// 3 : moped
// 4 : motorcycle
// 5 : passengerCar
// 6 : bus
// 7 : lightTruck
// 8 : heavyTruck
// 9 : trailer
// 10 : specialVehicles
// 11 : tram
// 15 : roadSideUnit
// -------------------------------------------------------------
carStationType = camPdu.cam.camParameters.basicContainer.stationType;
carStationId = camPdu.header.stationID;

   
// Enumeration values for speedValue: 
// -------------------------------------------------------------
// 16383 : unavailable
// -------------------------------------------------------------
   carSpeed = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.speed.speedValue;
   carSteerAngle = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.steeringWheelAngle.steeringWheelAngleValue;
 
 
    distanceToCam = API_PosCalcDistance(vehicleCamLat, vehicleCamLong, camLat, camLong);
  
    // Debug print statement to check the conditions
    //write("Debug: distanceToCam = %f, camSpeed = %d, stationType = %d, stationID = %d ", distanceToCam, camSpeed, carStationType, carStationId);
//      write("Debug: vehicleCamLat: %f, vehicleCamLong: %f", vehicleCamLat, vehicleCamLong);
//      write("Debug: camLat: %f, camLong: %f", camLat, camLong);
//      write("Debug: Distance to Cam: %f", distanceToCam);
 //       write("Debug: Steering wheel angle : %f", distanceToCam);
//     write("Test: Car ID %d has %d steeting wheel angle. ", carStationId, carSteerAngle);
    
    
       // CHECK CONDITIONS FOR RSU BASED ON SPEED AND POSITION
   if (distanceToCam <= 0.7  && distanceToCam > 0 && carStationType == 5 && carSpeed > 0  )
      
  //  if (distanceToCam <= 30  && distanceToCam > 0 && carStationType == 5 && carSpeed > 0  )       
   {
     write("Test: Car ID %d is within 0.7 meters of a stationary RSU. Distance: %f meters", carStationId, distanceToCam);
    
    @sysvar::distanceToCam::distanceToCam = 1;
     setTimer(lightTimer, 0);
      
//      CheckRSUAndLED();
      
    }

    
//    else
    
//        @sysvar::distanceToCam::distanceToCam = 0;
    
  
   }
}


// Callback function before sending CAM messages from IL
void OnPreTxCAM(LONG packet)
{
    struct CAM camPdu; 
  
    // Save the current vehicle's co-ordinates for future distance calculations.
  
    if (!API_GetCAMParams(packet, camPdu))
     {
        vehicleCamLong = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
        vehicleCamLat = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
        followSpeed = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.speed.speedValue;
        
       //` write(" *** Vehicle long = %f lat = %f \n",  vehicleCamLong,  vehicleCamLat );
     }
    
  
    
}

// Callback function on receiving DENM messages
void OnRxDENM(long channel, long dir, long radioChannel, long signalStrength, long signalQuality, long packet)
{
  struct DENM denmPdu;
  int type;
  int stationId;
  
  write(" *** DENM Received ");
   if (!API_GetDENMparams(packet, denmPdu))
  {
    stationId = denmPdu.header.stationID;
    write(" DENM stationId = %d", stationId);
    type = denmPdu.denm.situation.eventType.causeCode;
    write(" DENM Cause Code = %d", type);
  }
    
}

// Callback function before sending DENM messages from IL
void OnPreTxDENM(LONG packet)
{

}



//on key 'x'
//{
  
//  /*
//    Example of how to transmit a DENM messaage.  Note that other parameters such as Station Id, relevance area etc. would need to be
//    included in a realistic DENM message.
//  */
  
//  long packet;
//  double eventPosLat, eventPosLon, eventPosElev;

//  eventPosLat = 48.8233831512772;
//  eventPosLon = 9.093631893371;
//  eventPosElev = 305;

//  packet = C2xInitPacket("DENM");
//  C2xSetTokenInt(packet, "DENM", "denm.situation.eventType.causeCode", 91); // VehicleBreakDown
//  C2xSetTokenPhys(packet, "DENM", "denm.management.eventPosition.latitude", eventPosLat);
//  C2xSetTokenPhys(packet, "DENM", "denm.management.eventPosition.longitude", eventPosLon);
//  C2xSetTokenPhys(packet, "DENM", "denm.management.eventPosition.altitude.altitudeValue", eventPosElev);

// // C2xApplyPathHistory(packet, eventPosLat, eventPosLon, 305, 800, 20, 1);

//  C2xCompletePacket(packet);
//  C2xOutputPacket(packet);
//}





void trafficLightGreen() {
    @sysvar::trafficLightState::trafficLightState = 0; // 0 = Green, 1 = Yellow, 2 = Red
}
void trafficLightYellow() {
    @sysvar::trafficLightState::trafficLightState = 1; // 0 = Green, 1 = Yellow, 2 = Red
}

void trafficLightRed() {
    @sysvar::trafficLightState::trafficLightState = 2; // 0 = Green, 1 = Yellow, 2 = Red
}

on timer lightTimer {
    switch (trafficLightState) {
        case 0: // Green
            trafficLightYellow(); // Light switches from green to yellow
              setTimer(lightTimer, 5000);
            break;
        case 1: // Yellow
            trafficLightRed();// Light switches from yellow to red
              setTimer(lightTimer, 30000);
            break;
        case 2: // Red
            trafficLightGreen();// Light switches from red to green
              setTimer(lightTimer, 20000);
            break;
            
    }
}

    


// Function to determine if a vehicle is approaching a junction
//int isApproachingJunction(int carPositionLat, int carPositionLong) {
//    // Add logic here to determine if the vehicle is approaching a junction
//    // You might compare the vehicle's position with the coordinates of known junctions
//    // For now condition based on the latitude and longitude
//    if (carPositionLat > 0 && carPositionLong > 0) {
//        return 1; // Vehicle is approaching a junction
//    } else {
//        return 0; // Vehicle is not approaching a junction
//    }
//}

//// Function to determine if a vehicle is allowed to turn at a junction
//int isTurningAllowed(int carStationId, int carSteerAngle) {
//    // logic here to determine if the vehicle is allowed to turn
//    // might check the current traffic regulations, road signs, or other factors
//    // right now only checking specific car ID and turning angle
//    if (carStationId % 2 == 0 && carSteerAngle > 180) {
//        return 0; // Turning is not allowed
//    } else {
//        return 1; // Turning is allowed
//    }
//}



void VehiclePosition(long packet, struct CAM camPdu)
 {
  int vehiclePosition =0 ;

  int carPositionLat = 0;
  int carPositionLong = 0;
  int  carStationId;
  double camLong;        
  double camLat;         
  long camStationType;   
  double distanceToCam;   
  long camSpeed;        
  long camHeading;      
  long camStationId;
  long leadSpeed;
  
  long carSpeed;

   
   
if (!API_GetCAMParams(packet, camPdu))
    {
        // Extract relevant information from the CAM message
        carPositionLong = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
        carPositionLat = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
        carStationId = camPdu.header.stationID;
        carSteerAngle = camPdu.cam.camParameters.highFrequencyContainer.basicVehicleContainerHighFrequency.steeringWheelAngle.steeringWheelAngleValue;

//        // Process position updates from vehicles
//        if (isApproachingJunction(carPositionLat, carPositionLong)) {
//            // Vehicle is approaching the junction
//            if (isTurningAllowed(carStationId, carSteerAngle)) {
//                // Allow the vehicle to proceed through the junction
////                sendProceedSignal(carStationId); <- This might be a SysVar showing LED based on this
//            } else {
//                // Disallow the vehicle from proceeding (e.g., signal to stop)
////                sendStopSignal(carStationId); <- This might be a SysVar showing LED based on this

//            }
//        }
    }
 }
 
 


 
//void junction {
//    lane dynamicLane {
//        id = 1;
//        dimensions = {
//            {laneBoundaries[0][0], laneBoundaries[0][1]},
//            {laneBoundaries[1][0], laneBoundaries[1][1]},
//            {laneBoundaries[2][0], laneBoundaries[2][1]},
//            {laneBoundaries[3][0], laneBoundaries[3][1]}
//        };
        
//        on entering {
//            if (carPositionX > 250 && carPositionY > 75 && carSteeringAngle < 45) {
//                // Vehicle is attempting to make a right turn but it's incorrect
//                // Implement action here (e.g., trigger a warning)
//                // Example: sendWarningSignal();
//                write("Incorrect right turn detected!");
//            }
//        }
//    }
//}


 
void carWillContinueRight(struct CAM camPdu) {
    int carX = 0;
    int carY = 0;
    carX = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    carY = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
    
    if (carX > previousCarX && carY < previousCarY) {
        write("Car is continuing to turn right.");
        
        previousCarX = carX;
        previousCarY = carY;
    } else {
        // Car is not continuing to turn right
        write("Car is not continuing to turn right.");
        // Implement additional actions here if needed
    }
}
 
 void defineLaneBoundaries(int laneId, int carPositionX, int carPositionY, struct CAM camPdu) {
    int laneStartX, laneStartY, laneEndX, laneEndY;
    carPositionX = camPdu.cam.camParameters.basicContainer.referencePosition.longitude / 1e07;
    carPositionY = camPdu.cam.camParameters.basicContainer.referencePosition.latitude / 1e07;
    // Define lane boundaries based on the laneId
    switch (laneId) {
        case 1: // left lane going up
            laneStartX = 100;
            laneStartY = 50;
            laneEndX = 300;
            laneEndY = 50;
            break;
        case 2: // right lane going up
            laneStartX = 300;
            laneStartY = 50;
            laneEndX = 300;
            laneEndY = 100;
            break;
        case 3: // left lane going down
            laneStartX = 300;
            laneStartY = 100;
            laneEndX = 100;
            laneEndY = 100;
            break;
        case 4: // right lane going down
            laneStartX = 100;
            laneStartY = 100;
            laneEndX = 100;
            laneEndY = 50;
            break;
            return;
    }
    
        // Check if the car's position violates lane boundaries
      if (carPositionX > laneStartX && carPositionX < laneEndX && carPositionY > laneStartY && carPositionY < laneEndY) {
          // Car is within the lane boundaries, check if it's lane 1
          if (laneId == 1 ) {
              // Car is in lane 1, check turning direction
              if (carSteeringAngle >= 45 ) {
                  // Car is turning right while in lane 1, trigger a warning
                  write("Warning: Car is turning right while in lane 1!");
                  
                  // sendWarningSignal();
              } else {
                if (carWillContinueRight(carPositionX, carPositionY)){
                  write("Warning: Car is continueing to turn right in lane 1");
                }
              }
          }
      
          if (laneId == 2 || laneId == 4) {
                  write("Warning: Car is on the wrong side of the road");
                  
                  // sendWarningSignal();
              }
          }
       else {
         
          write("Warning: Car is outside lane boundaries!");
           // sendWarningSignal();
          
      }
  }
  
  
//on message dynamicLaneEntering {
//    // Extract lane ID from the received message
//    int laneId = dynamicLaneEntering.laneId;
//    // Define lane boundaries for the entered lane
//    defineLaneBoundaries(laneId);
//}

// =============================================


